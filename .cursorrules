
# Algorand Agent Skills

These skills are manually installed from `algorand-devrel/algorand-agent-skills` because the VibeKit CLI installation encountered issues. They provide the AI with context for building, testing, and interacting with Algorand smart contracts.

---
## Skill: build-smart-contracts
name: build-smart-contracts
description: Build Algorand smart contracts using Algorand TypeScript (PuyaTs) or Algorand Python (PuyaPy). Use when creating new smart contracts from scratch, adding features or methods to existing contracts, understanding Algorand contract development patterns, or getting guidance on contract architecture. Strong triggers include "create a smart contract", "write a contract that...", "build a voting contract", "implement an NFT contract", "add a method to the contract".

# Building Smart Contracts

Create modern Algorand smart contracts in Algorand TypeScript or Algorand Python—statically-typed subsets compiled to TEAL bytecode by the Puya compiler.

## Overview / Core Workflow

1. Search Algorand documentation for concepts and best practices
2. Retrieve canonical examples from priority repositories
3. Generate code adapting examples to requirements
4. Include integration tests using generated clients
5. Build and test with AlgoKit commands

## How to proceed

1. **Search documentation first:**
   - Use `kapa_search_algorand_knowledge_sources` MCP tool for conceptual guidance
   - If MCP unavailable, use web search: "site:dev.algorand.co {concept}"
   - If no results, proceed with caution using known patterns

2. **Retrieve canonical examples:**
   - Priority 1: `algorandfoundation/devportal-code-examples`
   - Priority 2: `algorandfoundation/puya-ts` (examples/)
   - Priority 3: `algorandfoundation/algokit-typescript-template`
   - Always include corresponding test files

3. **Generate code:**
   - Default to TypeScript unless user explicitly requests Python
   - Adapt examples carefully, preserving safety checks
   - Follow syntax rules from `algorand-typescript` skill

4. **Include tests:**
   - Always include or suggest integration tests
   - Use generated clients for testing contracts
   - See `test-smart-contracts` skill for patterns

5. **Build and test:**
   ```bash
   algokit project run build   # Compile contracts
   algokit project run test    # Run tests
   ```

## Important Rules / Guidelines

- **NEVER use PyTEAL or Beaker** — these are legacy, superseded by Puya
- **NEVER write raw TEAL** — always use Algorand TypeScript/Python
- **NEVER import external libraries** into contract code
- **Default to TypeScript** unless user explicitly requests Python
- **Always search docs first** before writing code
- **Always retrieve examples** from priority repositories

## Common Variations / Edge Cases

| Scenario | Approach |
|----------|----------|
| Box storage patterns | Check `devportal-code-examples/contracts/BoxStorage/` |
| Inner transactions | Search for "itxn" patterns in puya-ts examples |
| ARC-4 methods | See `puya-ts/examples/hello_world_arc4/` |
| State management | Check GlobalState, LocalState patterns in examples |
| Python contracts | Use `algorandfoundation/puya` instead of puya-ts |
| Python syntax help | Consult `references/python/` subfolder for Python-specific patterns |

---
## Skill: call-smart-contracts

# Calling Smart Contracts

## Overview / Core Workflow
1. Build the contract: `algokit project run build`
2. Deploy using CLI: `algokit project deploy localnet`
3. Write TypeScript scripts using the generated client
4. Run scripts: `npx tsx scripts/my-script.ts`

## How to proceed

### 1. Build the Contract
```bash
algokit project run build
```
This compiles your contract and generates:
- `artifacts/<ContractName>/<ContractName>.arc56.json` — ARC-56 app spec
- `artifacts/<ContractName>/client.ts` — Generated TypeScript client

### 2. Deploy to Localnet
```bash
# Start localnet if not running
algokit localnet start

# Deploy (runs deploy-config.ts)
algokit project deploy localnet
```
The deployment script (`smart_contracts/deploy-config.ts`) handles:
- Idempotent deployment (safe to re-run)
- App ID tracking
- Initial state setup

### 3. Interact Using Generated Client
Create scripts in your project to call contract methods. Example structure:

```typescript
// scripts/call-contract.ts
import { AlgorandClient } from '@algorandfoundation/algokit-utils'
import { CounterClient } from '../smart_contracts/artifacts/Counter/client'

async function main() {
  // Connect to localnet
  const algorand = AlgorandClient.fromEnvironment()

  // Get the default account (localnet dispenser)
  const deployer = await algorand.account.fromEnvironment('DEPLOYER')

  // Create client for deployed app
  const client = algorand.client.getTypedAppClientById(CounterClient, {
    appId: BigInt(1234), // Replace with actual App ID
    sender: deployer,
  })

  // Call a method
  const result = await client.send.increment({})
  console.log('New count:', result.return)

  // Read global state
  const state = await client.state.global.getAll()
  console.log('Global state:', state)
}
main().catch(console.error)
```

Run with:
```bash
npx tsx scripts/call-contract.ts
```

---
## Skill: test-smart-contracts

# Testing Smart Contracts

## Default: Integration Tests (E2E)
**Always write integration tests unless the user explicitly requests unit tests.** Integration tests run against LocalNet and test real contract behavior.

## How to proceed
1. **Locate the generated client** in `artifacts/clients/<ContractName>/<ContractName>Client.ts`
2. **Import the Factory** (e.g., `MyContractFactory`) - NOT the Client directly
3. **Use the deploy helper pattern** shown above
4. **Call methods via `client.send.methodName()`** or `client.newGroup().methodName().send()`

## Critical Rules
| Rule | Details |
|------|---------|
| **Use newGroup() for chaining** | `client.newGroup().method1().method2().send()` |
| **Struct returns are tuples** | `const [id, name] = result.return as [bigint, string]` |
| **Fund app for BoxMap** | Send payment to `client.appAddress` before box operations |
| **Opt-in before local state** | `await client.newGroup().optIn.optInToApplication().send()` |
